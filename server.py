import os
import logging
from typing import List, Dict, Any
from dotenv import load_dotenv
from mcp.server.fastmcp import FastMCP
from neo4j import GraphDatabase, exceptions

# Setup professional logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

load_dotenv()

from mcp.server.transport_security import TransportSecuritySettings

# Initialize FastMCP with DNS rebinding protection DISABLED
mcp = FastMCP(
    "SentinelGraph-Engine",
    transport_security=TransportSecuritySettings(
        enable_dns_rebinding_protection=False
    )
)

# Neo4j Connection Logic
class Neo4jManager:
    def __init__(self):
        self.uri = os.getenv("NEO4J_URI")
        self.user = os.getenv("NEO4J_USERNAME") 
        self.password = os.getenv("NEO4J_PASSWORD")
        if not all([self.uri, self.user, self.password]):
            logger.error("CRITICAL: One or more Neo4j environment variables are MISSING!")
        else:
            logger.info(f"Neo4jManager initialized with URI: {self.uri}")
        self._driver = None

    @property
    def driver(self):
        if self._driver is None:
            try:
                # Log 2: Track the start of the driver creation
                logger.info("Attempting to create Neo4j driver...")
                self._driver = GraphDatabase.driver(
                    self.uri, 
                    auth=(self.user, self.password),
                    # Optimization: Fail fast to avoid Dify timeouts
                    connection_timeout=15.0, 
                    max_connection_lifetime=30 * 60
                )
                # Log 3: Confirm driver object created
                logger.info("Neo4j driver created successfully.")
            except Exception as e:
                logger.error(f"Failed to create Neo4j driver: {e}")
                raise
        return self._driver

    def execute_read(self, cypher: str, parameters: Dict[str, Any] = None) -> List[Dict[str, Any]]:
        """
        Executes a read query and sanitizes output for the LLM.
        """
        with self.driver.session() as session:
            try:
                result = session.run(cypher, parameters or {})
                # IMPORTANT: Convert all values to strings to prevent 'FLOAT' 
                # vs 'NODE' type mismatch errors during the LLM's reasoning.
                return [{k: str(v) for k, v in record.data().items()} for record in result]
            except Exception as e:
                logger.error(f"Cypher execution failed: {e}")
                return [{"error": str(e)}]

# Initialize global manager
db = Neo4jManager()

@mcp.tool()
def get_graph_schema() -> str:
    """
    Optimized Schema Discovery: Retrieves labels, relationships, and properties 
    in a single, high-speed database call.
    """
    logger.info("Performing high-speed schema discovery...")
    
    combined_query = """
    CALL db.labels() YIELD label
    WITH collect(label) AS node_labels
    CALL db.relationshipTypes() YIELD relationshipType
    WITH node_labels, collect(relationshipType) AS rel_types
    MATCH (n)
    WITH node_labels, rel_types, labels(n) AS node_labels_instance, keys(n) AS keys
    UNWIND node_labels_instance AS label
    UNWIND keys AS key
    WITH node_labels, rel_types, label, collect(DISTINCT key) AS properties
    RETURN {
        node_labels: node_labels,
        relationship_types: rel_types,
        node_properties: collect({label: label, properties: properties})
    } AS schema
    """
    try:
        result = db.execute_read(combined_query)
        schema_info = result[0]['schema'] if result else "Graph is currently empty."
        return f"Current Enterprise Schema: {schema_info}"
    except Exception as e:
        logger.error(f"Schema discovery failed: {e}")
        return f"Error retrieving schema: {str(e)}"

@mcp.tool()
def execute_cypher_search(cypher_query: str) -> str:
    """
    GENERIC GRAPH SEARCH: Executes a read-only Cypher query generated by the LLM.
    Use this to perform RCA, Impact Analysis, or Topology discovery.
    """
    logger.info(f"Executing LLM-generated query: {cypher_query}")
    try:
        if any(word in cypher_query.upper() for word in ["CREATE", "DELETE", "SET", "REMOVE", "DROP", "MERGE"]):
            return "Error: This tool is restricted to read-only (MATCH/RETURN) operations for safety."
        
        results = db.execute_read(cypher_query)
        if not results:
            return "Query successful, but no data was found matching those criteria."
        return f"Query Results: {results}"
    except Exception as e:
        return f"Cypher Execution Error: {str(e)}"

@mcp.tool()
def echo_health() -> str:
    """Verifies connectivity between Dify and Render without hitting Neo4j."""
    return "SentinelGraph Engine: Connection Healthy."

import uvicorn
import os

from starlette.responses import JSONResponse

# Add this route to your Starlette app inside the 'if __name__ == "__main__":' block
if __name__ == "__main__":
    app = mcp.sse_app()
    
    # NEW: Add a dedicated endpoint for Dify's Custom Tool discovery
    # This prevents the infinite spinning by giving Dify a fast JSON response
    @app.route("/health")
    async def health_status(request):
        return JSONResponse({"status": "ready", "engine": "SentinelGraph"})
    
    # 1. FIX: Override the host validation security for Render deployment
    # We tell the transport layer to trust our Render domain and Dify
    os.environ["MCP_TRANSPORT_ALLOWED_HOSTS"] = "sentinelgraph.onrender.com,cloud.dify.ai"
    
    # 2. Bind to 0.0.0.0 for external cloud access
    port = int(os.getenv("PORT", 10000))
    logger.info(f"Production Launch: SentinelGraph SSE Server on port {port}")
    
    # 3. Use Uvicorn with a clean configuration
    uvicorn.run(
        app, 
        host="0.0.0.0", 
        port=port,
        proxy_headers=True,               # Trust Render's proxy headers
        forwarded_allow_ips='*'           # Allow the proxy to forward the Host
    )