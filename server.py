import os
import logging
from typing import List, Dict, Any
from dotenv import load_dotenv
from mcp.server.fastmcp import FastMCP
from neo4j import GraphDatabase, exceptions

# Setup professional logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("SentinelGraph-Production")

load_dotenv()

# Initialize FastMCP Server
mcp = FastMCP("SentinelGraph-Engine")

# Neo4j Connection Logic
class Neo4jManager:
    def __init__(self):
        self.uri = os.getenv("NEO4J_URI")
        self.user = os.getenv("NEO4J_USERNAME") 
        self.password = os.getenv("NEO4J_PASSWORD")
        self._driver = None

    @property
    def driver(self):
        if self._driver is None:
            self._driver = GraphDatabase.driver(self.uri, auth=(self.user, self.password))
        return self._driver

    def execute_read(self, cypher: str, parameters: Dict[str, Any] = None) -> List[Dict[str, Any]]:
        """
        Executes a read query and sanitizes output for the LLM.
        """
        with self.driver.session() as session:
            try:
                result = session.run(cypher, parameters or {})
                # IMPORTANT: Convert all values to strings to prevent 'FLOAT' 
                # vs 'NODE' type mismatch errors during the LLM's reasoning.
                return [{k: str(v) for k, v in record.data().items()} for record in result]
            except Exception as e:
                logger.error(f"Cypher execution failed: {e}")
                return [{"error": str(e)}]

# Initialize global manager
db = Neo4jManager()

@mcp.tool()
@mcp.tool()
def get_graph_schema() -> str:
    """
    Optimized Schema Discovery: Retrieves labels, relationships, and properties 
    in a single, high-speed database call.
    """
    logger.info("Performing high-speed schema discovery...")
    
    # This single query replaces the previous three separate calls
    combined_query = """
    CALL db.labels() YIELD label
    WITH collect(label) AS node_labels
    CALL db.relationshipTypes() YIELD relationshipType
    WITH node_labels, collect(relationshipType) AS rel_types
    MATCH (n)
    WITH node_labels, rel_types, labels(n) AS node_labels_instance, keys(n) AS keys
    UNWIND node_labels_instance AS label
    UNWIND keys AS key
    WITH node_labels, rel_types, label, collect(DISTINCT key) AS properties
    RETURN {
        node_labels: node_labels,
        relationship_types: rel_types,
        node_properties: collect({label: label, properties: properties})
    } AS schema
    """
    try:
        result = db.execute_read(combined_query)
        schema_info = result[0]['schema'] if result else "Graph is currently empty."
        return f"Current Enterprise Schema: {schema_info}"
    except Exception as e:
        logger.error(f"Schema discovery failed: {e}")
        return f"Error retrieving schema: {str(e)}"

@mcp.tool()
def execute_cypher_search(cypher_query: str) -> str:
    """
    GENERIC GRAPH SEARCH: Executes a read-only Cypher query generated by the LLM.
    Use this to perform RCA, Impact Analysis, or Topology discovery.
    """
    logger.info(f"Executing LLM-generated query: {cypher_query}")
    try:
        if any(word in cypher_query.upper() for word in ["CREATE", "DELETE", "SET", "REMOVE", "DROP", "MERGE"]):
            return "Error: This tool is restricted to read-only (MATCH/RETURN) operations for safety."
        
        results = db.execute_read(cypher_query)
        if not results:
            return "Query successful, but no data was found matching those criteria."
        return f"Query Results: {results}"
    except Exception as e:
        return f"Cypher Execution Error: {str(e)}"

import uvicorn
import os

if __name__ == "__main__":
    # 1. Get the underlying Starlette app for SSE transport
    # The method is sse_app(), which is specifically for this purpose
    app = mcp.sse_app()
    
    # 2. Get the Port from Render's environment (standard practice)
    port = int(os.getenv("PORT", 8000))
    
    # 3. Use Uvicorn to run the app on 0.0.0.0
    # This ensures Render can bind to the port and route traffic
    uvicorn.run(app, host="0.0.0.0", port=port)