import os
import logging
from typing import List, Dict, Any
from dotenv import load_dotenv
from mcp.server.fastmcp import FastMCP
from neo4j import GraphDatabase, exceptions

# Setup professional logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger("SentinelGraph-Production")

load_dotenv()

# Initialize FastMCP Server
mcp = FastMCP("SentinelGraph-Engine")

# Neo4j Connection Logic
class Neo4jManager:
    def __init__(self):
        self.uri = os.getenv("NEO4J_URI")
        self.user = os.getenv("NEO4J_USERNAME") 
        self.password = os.getenv("NEO4J_PASSWORD")
        self._driver = None

    @property
    def driver(self):
        if self._driver is None:
            self._driver = GraphDatabase.driver(self.uri, auth=(self.user, self.password))
        return self._driver

    def execute_read(self, cypher: str, parameters: Dict[str, Any] = None) -> List[Dict[str, Any]]:
        """
        Executes a read query and sanitizes output for the LLM.
        """
        with self.driver.session() as session:
            try:
                result = session.run(cypher, parameters or {})
                # IMPORTANT: Convert all values to strings to prevent 'FLOAT' 
                # vs 'NODE' type mismatch errors during the LLM's reasoning.
                return [{k: str(v) for k, v in record.data().items()} for record in result]
            except Exception as e:
                logger.error(f"Cypher execution failed: {e}")
                return [{"error": str(e)}]

# Initialize global manager
db = Neo4jManager()

@mcp.tool()
def get_graph_schema() -> str:
    """
    DYNAMIC SCHEMA DISCOVERY: Returns all Node Labels, Relationship Types, 
    and a sample of properties for each. Use this FIRST to understand the graph structure.
    """
    logger.info("LLM requested graph schema...")
    
    # 1. Get Labels
    labels = db.execute_read("CALL db.labels()")
    labels_list = [l['label'] for l in labels]
    
    # 2. Get Relationships
    rels = db.execute_read("CALL db.relationshipTypes()")
    rels_list = [r['relationshipType'] for r in rels]
    
    # 3. Get Sample Properties (Generic Introspection)
    prop_query = """
    MATCH (n) 
    WITH labels(n) AS labels, keys(n) AS keys 
    UNWIND labels AS label 
    UNWIND keys AS key 
    RETURN DISTINCT label, collect(DISTINCT key) AS properties
    """
    props = db.execute_read(prop_query)
    
    schema_info = {
        "node_labels": labels_list,
        "relationship_types": rels_list,
        "node_properties": {p['label']: p['properties'] for p in props}
    }
    
    return f"Current Enterprise Schema: {schema_info}"

@mcp.tool()
def execute_cypher_search(cypher_query: str) -> str:
    """
    GENERIC GRAPH SEARCH: Executes a read-only Cypher query generated by the LLM.
    Use this to perform RCA, Impact Analysis, or Topology discovery.
    """
    logger.info(f"Executing LLM-generated query: {cypher_query}")
    try:
        if any(word in cypher_query.upper() for word in ["CREATE", "DELETE", "SET", "REMOVE", "DROP", "MERGE"]):
            return "Error: This tool is restricted to read-only (MATCH/RETURN) operations for safety."
        
        results = db.execute_read(cypher_query)
        if not results:
            return "Query successful, but no data was found matching those criteria."
        return f"Query Results: {results}"
    except Exception as e:
        return f"Cypher Execution Error: {str(e)}"

if __name__ == "__main__":
    # We must bind to 0.0.0.0 so Render can route traffic to the container
    # Port is dynamically pulled from Render's environment, defaulting to 8000
    port = int(os.getenv("PORT", 8000))
    mcp.run(transport='sse', host="0.0.0.0", port=port)